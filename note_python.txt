General
	ALT+P ALT+N : command history (IDLE)
	comment : # single line, '''multi line'''
	// : divide with integer answer, rounded down, 5//3 = 1
	** : power, 2**4 = 16
	string
		'...',"...",'''...''' for multi-line
		r'...' : treat string as raw, special character turned off, except ' " '''
		string* : add string multiple times, 'hello'*3 = 'hellohellohello'

built-in functions
	print() : print to console
		print('Hi '+str(5))
		print('''
			This is a simple
			multi-line print
			pretty cool!''')
		print('Hello,','my name is','John Doh')
	help() : interactive help guide
		https://docs.python.org/3/library/functions.html
	type() : type of object
	dir() : list of objects in workspace (IDLE?)
	eval() : evaluate a string and returns its content's meaning, no security
		used for string form object conversion
	exec() : eval+ version, evaluate a string and compile&execute its content meaning, no security
		can define variables and functions
	split() : split string to list
		my_list = 'some\nstring'.split('\n')
		print(my_list)
	min() max() : return lesser/greater value
	abs() round() str() int() float()

loop
	for loop
		for x in y : ...
			loop x in y, y = List or number range, x= element of y
		[print x for x in [5,3,4]]
			oneline
		for i, x in y : get index i, value x, in y
			List : y = enumerate(z)
			Dictionary : y = z.items()
			Numpy array : y = np.nditer(z)
	while loop
		while x : ...
		loop if condition x is true
	related
		range(a,b,c) : range of numbers from a to b-1 of interval c
		break : break out of current loop
		continue : skip current and jump to next iteration of loop
	
condition
	if x:
		print('if condition x is true print this')
	elif y:
		print('else if condition y is true print this')
	else:
		print('else if x and y is both false print this')

function
	definition
		def example():
 			print('basic function')
			z = 3+9
			print(z)
		example()
	parameter
		def simple_sub(num1,num2):
			answer = num1 - num2
			print(num1,'-',num2,'=',answer)
		simple_sub(3,5)
		simple_sub(num1=5,num2=3)
	parameter default
		def simple(num1,num2=5):
			print(num1,num2)
		simple(3)
	return
		function returns something
		def example(a, b):
 			c = a + b
			return c
		print(example(5,3))
	flexible number of parameters
		function with number of parameters that can vary
		def add(*args):
			total=0
			for arg in args:
				total += arg
			print(total)	
		add(2,5,3)
	unpacking parameters
		pass parameters to function as list
		def person_desc(name, age, job, home):
		    desc = name + ' is ' + str(age) + ' years old, and lives in ' + home
    			print(desc)
		person_desc('John', 48, 'programmer', 'USA')
		person = ['Jane', 24,'nurse','Brazil']
		person_desc(*person)

variable scope : global, local
	x = 6
	y = 11
	def example():
		z = 5
		print('z=',z)
		global x
		x += 1
		print('x=',x)
	example()

file manipulation
	open file : open()
		'w':write, 'a':append, 'r':read
		writefile = open('exampleFile.txt','w')
	write file
		write() : write to file
			open with 'w':overwrite, 'a': add at end
		writefile.write('some text')
	read file
		read() : read from file, open() with 'r'
		readlines()
		text = readfile.read()
	close file
		close() : close file and free memory
		writefile.close()

class and OOP
	class : groups functions and variables, like file directory
		class Calculator:
			def add(x,y):
				result = x+y
				print(result)
			def sub(x,y):
				result = x-y
				print(result)
		Calculator.add(3,5)
		Calculator.sub(5,13)
	object : copy of a class, objects from same class are independent to each other
		class Enemy:
			life = 6
			def attack(self):
				self.life -= 1
				print('Outch!')
			def check_life(self):
				if self.life <= 0:
					print("I'm dead!")
				else:
					print(self.life, "left.")
		enemy1 = Enemy()
		enemy2 = Enemy()
		enemy1.attack()
		enemy1.attack()
		enemy1.check_life()
		enemy2.check_life()
	constructor : function(__init__) that is executed during object creation, initialization
		class Enemy:
			def __init__(self, name, hp):
				self.name = name
				self.hp = hp
			def info(self):
				print(self.name + ' has', self.hp, 'hp')
		enemy1 = Enemy('Minion', 5)
		enemy2 = Enemy('Boss', 100)
		enemy1.info()
		enemy2.info()
	class vs instance variable(?)
		class variable : within class but outside class method, shared by objects of class
		instance variable : within class method
	inheritance : passing characteristics of a class(parent) to another class(child), method overide, multiple inheritance
		class Parent:
			def last_name(self):
				return 'Kim'
			def first_name(self):
				return 'SK'
		class Child(Parent):
			def first_name(self):
				return 'Curie'

		p1 = Parent()
		p2 = Child()
		print(p1.first_name(), p1.last_name())
		print(p2.first_name(), p2.last_name())
		class Sense:
			def eye(self):
				print('I can see')
		class Action:
			def leg(self):
				print('I can run')
		class Human:
			def brain(self):
				print('I can understand')
		class Person(Sense, Action, Human):
			pass
		p1 = Person()
		p1.eye()
		p1.arm()
		p1.brain()

user input
	x = input ('What is your name? ')

module
	install
		http://www.lfd.uci.edu/~gohlke/pythonlibs/
		pip install ...
	import
		import statistics as s
		from statistics import median, stdev as d, variance as v
	create
		module is a python script with functions defined
		module file must be in Lib Lib/site-packages or path defined folder, else import don't work
		use if __name__ == '__main__' for excluding code when used as module

data structures
	object containing multiple data with different ways of manipulation
	list
		container of data, data is mutable(manupilated)
		my_list = ['John', 'Bob','Henry','Bob']
		print(my_list) -> ['John', 'Bob', 'Henry', 'Bob']
	set
		data must be unique, can't be repeated
		my_set = {'John', 'Bob','Henry','Bob'}
		print(my_set) -> {'Bob', 'Henry', 'John'}
	tuple
		data is immutable(unchangable), handle data fast
		my_tuple = (1,2,3)
	dictionary
		container of pairs of data, key and value
		my_dictionary = {'Jack':15,'Alice':12,'Bob':22,'Kevin':17}
	zip
		grouped lists with index matched
		in for loop drops left overs
		names = ['Jessica', 'Daniel', 'Edward', 'Oscar', 'Henry']
		ages = ['15', '27', '77', '102']
		personDict2 = {a:b for a,b in zip(names,ages)}
		            = {'Jessica': '15', 'Daniel': '27', 'Edward': '77', 'Oscar': '102'}

csv
	code
		import csv
		with open('s28.csv') as csvfile:
    			readCSV = csv.reader(csvfile, delimiter=',')
	note
		when file is used, can't use?

error/exception handling
	overview
		process non sytax errors
		do code1, if error in code1 do code2, always do code3
		'except' can process error as whole or specific errors
		'finally' logic will always be done
	code
		try:
			code1
		except:
			code2
		finally:
			code3

thread
	multiple processing
	threading.Lock()

python 2to3
	convert python 2 code to 3 code
	python 2to3.py -w targetfile
	-w : commit and backup, else show only
